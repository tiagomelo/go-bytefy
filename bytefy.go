// Copyright (c) 2025 Tiago Melo. All rights reserved.
// Use of this source code is governed by the MIT License that can be found in
// the LICENSE file.

package imgbytefy

import (
	"bytes"
	"fmt"
	"io"
	"path/filepath"

	"github.com/pkg/errors"
)

var (
	// fsProvider is a variable of interface type fileSystem. It abstracts
	// file system operations and allows the use of different file system
	// implementations (like mocks for testing).
	fsProvider fileSystem = osFileSystem{}

	// templateProcessorProvider is a variable of interface type templateProcessor.
	// It abstracts template parsing and execution and allows different implementations.
	templateProcessorProvider templateProcessor = textTemplateProcessor{}
)

const (
	tpl = `// {{.GeneratedBy}}

package {{.PackageName}}

var {{.ArrayName}} []byte = []byte{{.FormattedBody}}
`
	programName    = "go-image-bytefy"
	programVersion = "0.1.0"
	programURL     = "https://github.com/tiagomelo/go-image-bytefy"
)

type templateData struct {
	GeneratedBy   string
	PackageName   string
	ArrayName     string
	FormattedBody string
}

// Bytefy converts an image file into a Go byte array and generates a Go source file
// that contains the byte representation of the image.
func Bytefy(inputFile, outputFile, packageName, identifier string) error {
	if !isValidGoIdent(identifier) {
		return fmt.Errorf("'%s' is not a valid Go identifier", identifier)
	}

	inFile, err := fsProvider.Open(inputFile)
	if err != nil {
		return errors.Wrapf(err, "failed to open input file: %s", inputFile)
	}
	defer inFile.Close()

	var byteStrings []string
	buf := make([]byte, 4096)
	for {
		n, err := inFile.Read(buf)
		if n > 0 {
			for _, b := range buf[:n] {
				byteStrings = append(byteStrings, fmt.Sprintf("0x%02x", b))
			}
		}
		if err == io.EOF {
			break
		}
		if err != nil {
			return errors.Wrap(err, "error reading input")
		}
	}

	var formatted bytes.Buffer
	formatted.WriteString("{")
	for i, b := range byteStrings {
		if i%12 == 0 {
			formatted.WriteString("\n\t")
		}
		formatted.WriteString(b)
		formatted.WriteString(", ")
	}
	formatted.WriteString("\n}")

	data := templateData{
		GeneratedBy:   fmt.Sprintf("File generated by %s v%s (%s)", programName, programVersion, programURL),
		PackageName:   packageName,
		ArrayName:     identifier,
		FormattedBody: formatted.String(),
	}

	executor, err := templateProcessorProvider.Parse("embed", tpl)
	if err != nil {
		return errors.Wrap(err, "template parsing error")
	}

	if outputFile == "" {
		inputBase := filepath.Base(inputFile)
		outputFile = filepath.Join(packageName, inputBase+".go")
	}

	if err := fsProvider.MkdirAll(filepath.Dir(outputFile), 0755); err != nil {
		return errors.Wrapf(err, "failed to create output directory: %s", filepath.Dir(outputFile))
	}

	var bufOut bytes.Buffer
	if err := executor.Execute(&bufOut, data); err != nil {
		return errors.Wrap(err, "template execution error")
	}

	if err := fsProvider.WriteFile(outputFile, bufOut.Bytes(), 0644); err != nil {
		return errors.Wrapf(err, "failed to write output file: %s", outputFile)
	}

	return nil
}
